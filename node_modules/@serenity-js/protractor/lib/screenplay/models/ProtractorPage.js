"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtractorPage = void 0;
const web_1 = require("@serenity-js/web");
const url_1 = require("url");
const promised_1 = require("../promised");
class ProtractorPage extends web_1.Page {
    constructor(browser, handle) {
        super(handle);
        this.browser = browser;
    }
    title() {
        return this.switchToAndPerform(async (browser) => {
            return (0, promised_1.promised)(browser.getTitle());
        });
    }
    name() {
        return this.switchToAndPerform(async (browser) => {
            return (0, promised_1.promised)(browser.executeScript('return window.name'));
        });
    }
    url() {
        return this.switchToAndPerform(async (browser) => {
            return new url_1.URL(await (0, promised_1.promised)(browser.getCurrentUrl()));
        });
    }
    async viewportSize() {
        return this.switchToAndPerform(async (browser) => {
            const calculatedViewportSize = await (0, promised_1.promised)(browser.executeScript(`return {
                    width:  Math.max(document.documentElement.clientWidth,  window.innerWidth || 0),
                    height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
                };`));
            if (calculatedViewportSize.width > 0 && calculatedViewportSize.height > 0) {
                return calculatedViewportSize;
            }
            // Chrome headless hard-codes window.innerWidth and window.innerHeight to 0
            return (0, promised_1.promised)(browser.manage().window().getSize());
        });
    }
    async setViewportSize(size) {
        return this.switchToAndPerform(async (browser) => {
            const desiredWindowSize = await (0, promised_1.promised)(browser.executeScript(`
                var currentViewportWidth  = Math.max(document.documentElement.clientWidth,  window.innerWidth || 0)
                var currentViewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
                
                return {
                    width:  Math.max(window.outerWidth  - currentViewportWidth  + ${size.width},  ${size.width}),
                    height: Math.max(window.outerHeight - currentViewportHeight + ${size.height}, ${size.height}),
                };
            `));
            return (0, promised_1.promised)(browser.manage().window().setSize(desiredWindowSize.width, desiredWindowSize.height));
        });
    }
    async close() {
        return this.switchToAndPerform(browser => (0, promised_1.promised)(browser.close()));
    }
    async closeOthers() {
        const windowHandles = await this.browser.getAllWindowHandles();
        for (const handle of windowHandles) {
            if (handle !== this.handle) {
                await this.browser.switchTo().window(handle);
                await this.browser.close();
            }
        }
        await this.browser.switchTo().window(this.handle);
    }
    async isPresent() {
        const currentPageHandle = await this.browser.getWindowHandle();
        const desiredPageHandle = this.handle;
        const isOpen = await this.browser.switchTo().window(desiredPageHandle).then(() => true, _error => false);
        await this.browser.switchTo().window(currentPageHandle);
        return isOpen;
    }
    async switchTo() {
        const originalWindowHandle = await this.browser.getWindowHandle();
        await this.browser.switchTo().window(this.handle);
        return {
            switchBack: async () => {
                await this.browser.switchTo().window(originalWindowHandle);
            }
        };
    }
    async switchToAndPerform(action) {
        const originalPageHandle = await this.browser.getWindowHandle();
        const desiredPageHandle = this.handle;
        const shouldSwitch = originalPageHandle !== desiredPageHandle;
        if (shouldSwitch) {
            await this.browser.switchTo().window(desiredPageHandle);
        }
        const result = await action(this.browser);
        if (shouldSwitch) {
            await this.browser.switchTo().window(originalPageHandle);
        }
        return result;
    }
}
exports.ProtractorPage = ProtractorPage;
//# sourceMappingURL=ProtractorPage.js.map