import { AnswersQuestions, UsesAbilities } from './actor';
import { Answerable } from './Answerable';
import { Interaction } from './Interaction';
import { Optional } from './Optional';
/**
 * @desc
 *  Enables the {@link Actor} to query the system under test.
 *
 * @example <caption>A basic Question</caption>
 *  import { Actor, AnswersQuestions, UsesAbilities, Question } from '@serenity-js/core'
 *  import { Ensure, equals } from '@serenity-js/assertions'
 *
 *  const LastItemOf = <T>(list: T[]): Question<T> =>
 *      Question.about('last item from the list', (actor: AnswersQuestions & UsesAbilities) => {
 *          return list[list.length - 1];
 *      });
 *
 *  Actor.named('Quentin').attemptsTo(
 *      Ensure.that(LastItemFrom([1,2,3]), equals(3)),
 *  );
 *
 * @example <caption>A question using the Actor's Ability to do something</caption>
 *  import { AnswersQuestions, UsesAbilities, Question } from '@serenity-js/core'
 *  import { CallAnApi } from '@serenity-js/rest'
 *
 *  const TextOfLastResponseStatus = () =>
 *      Question.about<number>(`the text of the last response status`, actor => {
 *          return CallAnApi.as(actor).mapLastResponse(response => response.statusText);
 *      });
 *
 *  @example <caption>Mapping answers to other questions</caption>
 *  import { Actor, AnswersQuestions, UsesAbilities, Question } from '@serenity-js/core'
 *  import { CallAnApi, LastResponse } from '@serenity-js/rest'
 *  import { Ensure, equals } from '@serenity-js/assertions';
 *
 *  const RequestWasSuccessful = () =>
 *      Question.about<number>(`the text of the last response status`, actor => {
 *          return LastResponse.status().answeredBy(actor) === 200;
 *      });
 *
 *  const actor = Actor.named('Quentin').whoCan(CallAnApi.at('https://myapp.com/api'));
 *
 *  actor.attemptsTo(
 *      Send.a(GetRequest.to('/books/0-688-00230-7')),
 *      Ensure.that(RequestWasSuccessful(), isTrue()),
 *  );
 *
 * @see {@link Actor}
 * @see {@link Interaction}
 * @see {@link Ability}
 *
 * @abstract
 */
export declare abstract class Question<T> {
    /**
     * @desc
     *  Factory method that simplifies the process of defining custom questions.
     *
     * @example
     *  const EnvVariable = (name: string) =>
     *      Question.about(`the ${ name } env variable`, actor => process.env[name])
     *
     * @static
     *
     * @param {string} description
     * @param {function(actor: AnswersQuestions & UsesAbilities): R} body
     *
     * @returns {Question<R>}
     */
    static about<R>(description: string, body: (actor: AnswersQuestions & UsesAbilities) => Promise<R> | R): QuestionAdapter<Awaited<R>>;
    /**
     * @desc
     *  Checks if the value is a {@link Question}.
     *
     * @static
     *
     * @param {any} maybeQuestion
     *  The value to check
     *
     * @returns {boolean}
     */
    static isAQuestion<T>(maybeQuestion: unknown): maybeQuestion is Question<T>;
    protected static createAdapter<AT>(statement: Question<AT>): QuestionAdapter<Awaited<AT>>;
    /**
     * @desc
     *  Describes the subject of this {@link Question}.
     *
     * @returns {string}
     */
    abstract toString(): string;
    /**
     * @desc
     *  Changes the description of this question's subject.
     *
     * @param {string} subject
     * @returns {Question<T>}
     */
    abstract describedAs(subject: string): this;
    /**
     * @abstract
     */
    abstract answeredBy(actor: AnswersQuestions & UsesAbilities): T;
    as<O>(mapping: (answer: Awaited<T>) => Promise<O> | O): QuestionAdapter<O>;
}
declare global {
    interface ProxyConstructor {
        new <Source_Type extends object, Target_Type extends object>(target: Source_Type, handler: ProxyHandler<Source_Type>): Target_Type;
    }
}
export declare type ProxiedAnswer<Original_Type> = {
    [Field in keyof Omit<Original_Type, keyof QuestionStatement<Original_Type>>]: Original_Type[Field] extends (...args: infer OriginalParameters) => infer OriginalMethodResult ? (...args: {
        [P in keyof OriginalParameters]: Answerable<OriginalParameters[P]>;
    }) => {
        isPresent(): Question<Promise<boolean>>;
    } & QuestionAdapter<Awaited<OriginalMethodResult>> : {
        isPresent(): Question<Promise<boolean>>;
    } & QuestionAdapter<Awaited<Original_Type[Field]>>;
};
export declare type QuestionAdapter<Original_Type> = Question<Promise<Original_Type>> & Interaction & Optional & ProxiedAnswer<Original_Type>;
declare class QuestionStatement<Answer_Type> extends Interaction implements Question<Promise<Answer_Type>>, Optional {
    private subject;
    private readonly body;
    constructor(subject: string, body: (actor: AnswersQuestions & UsesAbilities, ...Parameters: any[]) => Promise<Answer_Type> | Answer_Type);
    /**
     * @desc
     *  Returns a Question that resolves to `true` if resolving the {@link QuestionStatement}
     *  returns a value other than `null` or `undefined` and doesn't throw errors.
     *
     * @returns {Question<Promise<boolean>>}
     */
    isPresent(): Question<Promise<boolean>>;
    answeredBy(actor: AnswersQuestions & UsesAbilities): Promise<Answer_Type>;
    performAs(actor: UsesAbilities & AnswersQuestions): Promise<void>;
    describedAs(subject: string): this;
    toString(): string;
    as<O>(mapping: (answer: Awaited<Answer_Type>) => (Promise<O> | O)): QuestionAdapter<O>;
}
export {};
