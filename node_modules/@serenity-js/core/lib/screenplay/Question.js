"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Question = void 0;
const io_1 = require("../io");
const Interaction_1 = require("./Interaction");
/**
 * @desc
 *  Enables the {@link Actor} to query the system under test.
 *
 * @example <caption>A basic Question</caption>
 *  import { Actor, AnswersQuestions, UsesAbilities, Question } from '@serenity-js/core'
 *  import { Ensure, equals } from '@serenity-js/assertions'
 *
 *  const LastItemOf = <T>(list: T[]): Question<T> =>
 *      Question.about('last item from the list', (actor: AnswersQuestions & UsesAbilities) => {
 *          return list[list.length - 1];
 *      });
 *
 *  Actor.named('Quentin').attemptsTo(
 *      Ensure.that(LastItemFrom([1,2,3]), equals(3)),
 *  );
 *
 * @example <caption>A question using the Actor's Ability to do something</caption>
 *  import { AnswersQuestions, UsesAbilities, Question } from '@serenity-js/core'
 *  import { CallAnApi } from '@serenity-js/rest'
 *
 *  const TextOfLastResponseStatus = () =>
 *      Question.about<number>(`the text of the last response status`, actor => {
 *          return CallAnApi.as(actor).mapLastResponse(response => response.statusText);
 *      });
 *
 *  @example <caption>Mapping answers to other questions</caption>
 *  import { Actor, AnswersQuestions, UsesAbilities, Question } from '@serenity-js/core'
 *  import { CallAnApi, LastResponse } from '@serenity-js/rest'
 *  import { Ensure, equals } from '@serenity-js/assertions';
 *
 *  const RequestWasSuccessful = () =>
 *      Question.about<number>(`the text of the last response status`, actor => {
 *          return LastResponse.status().answeredBy(actor) === 200;
 *      });
 *
 *  const actor = Actor.named('Quentin').whoCan(CallAnApi.at('https://myapp.com/api'));
 *
 *  actor.attemptsTo(
 *      Send.a(GetRequest.to('/books/0-688-00230-7')),
 *      Ensure.that(RequestWasSuccessful(), isTrue()),
 *  );
 *
 * @see {@link Actor}
 * @see {@link Interaction}
 * @see {@link Ability}
 *
 * @abstract
 */
class Question {
    /**
     * @desc
     *  Factory method that simplifies the process of defining custom questions.
     *
     * @example
     *  const EnvVariable = (name: string) =>
     *      Question.about(`the ${ name } env variable`, actor => process.env[name])
     *
     * @static
     *
     * @param {string} description
     * @param {function(actor: AnswersQuestions & UsesAbilities): R} body
     *
     * @returns {Question<R>}
     */
    static about(description, body) {
        return Question.createAdapter(new QuestionStatement(description, body));
    }
    /**
     * @desc
     *  Checks if the value is a {@link Question}.
     *
     * @static
     *
     * @param {any} maybeQuestion
     *  The value to check
     *
     * @returns {boolean}
     */
    static isAQuestion(maybeQuestion) {
        return !!maybeQuestion && !!maybeQuestion.answeredBy;
    }
    static createAdapter(statement) {
        return new Proxy(() => statement, {
            get(currentStatement, key, receiver) {
                const target = currentStatement();
                if (key === Symbol.toPrimitive) {
                    return (_hint) => {
                        return target.toString();
                    };
                }
                if (key in target) {
                    return Reflect.get(target, key);
                }
                if (key === 'then') {
                    return;
                }
                const originalSubject = (0, io_1.f) `${target}`;
                const fieldDescription = (typeof key === 'number' || /^\d+$/.test(String(key)))
                    ? `[${String(key)}]` // array index
                    : `.${String(key)}`; // field/method name
                return Question.about(`${originalSubject}${fieldDescription}`, async (actor) => {
                    const answer = await actor.answer(target);
                    if (!isDefined(answer)) {
                        return undefined; // eslint-disable-line unicorn/no-useless-undefined
                    }
                    const field = answer[key];
                    return typeof field === 'function'
                        ? field.bind(answer)
                        : field;
                });
            },
            set(currentStatement, key, value, receiver) {
                const target = currentStatement();
                return Reflect.set(target, key, value);
            },
            apply(currentStatement, _thisArgument, parameters) {
                const target = currentStatement();
                const parameterDescriptions = [
                    '(',
                    parameters.map(p => (0, io_1.f) `${p}`).join(', '),
                    ')'
                ].join('');
                return Question.about(target.toString() + parameterDescriptions, async (actor) => {
                    const params = [];
                    for (const parameter of parameters) {
                        const answered = await actor.answer(parameter);
                        params.push(answered);
                    }
                    const field = await actor.answer(target);
                    return typeof field === 'function'
                        ? field(...params)
                        : field;
                });
            },
            getPrototypeOf(currentStatement) {
                return Reflect.getPrototypeOf(currentStatement());
            },
        });
    }
    as(mapping) {
        return Question.about((0, io_1.f) `${this}.as(${mapping})`, async (actor) => {
            const answer = (await actor.answer(this));
            return mapping(answer);
        });
    }
}
exports.Question = Question;
class QuestionStatement extends Interaction_1.Interaction {
    constructor(subject, body) {
        super();
        this.subject = subject;
        this.body = body;
    }
    /**
     * @desc
     *  Returns a Question that resolves to `true` if resolving the {@link QuestionStatement}
     *  returns a value other than `null` or `undefined` and doesn't throw errors.
     *
     * @returns {Question<Promise<boolean>>}
     */
    isPresent() {
        return new IsPresent((0, io_1.f) `${this}.isPresent()`, this.body);
    }
    async answeredBy(actor) {
        const result = await this.body(actor);
        return isDefined(result)
            ? result
            : undefined;
    }
    async performAs(actor) {
        await this.body(actor);
    }
    describedAs(subject) {
        this.subject = subject;
        return this;
    }
    toString() {
        return this.subject;
    }
    as(mapping) {
        return Question.about((0, io_1.f) `${this}.as(${mapping})`, async (actor) => {
            const answer = await actor.answer(this);
            if (!isDefined(answer)) {
                return undefined; // eslint-disable-line unicorn/no-useless-undefined
            }
            return mapping(answer);
        });
    }
}
/**
 * @package
 */
class IsPresent extends Question {
    constructor(subject, body) {
        super();
        this.subject = subject;
        this.body = body;
    }
    async answeredBy(actor) {
        try {
            const answer = await this.body(actor);
            if (answer === undefined || answer === null) {
                return false;
            }
            if (this.isOptional(answer)) {
                return await actor.answer(answer.isPresent());
            }
            return true;
        }
        catch {
            return false;
        }
    }
    isOptional(maybeOptional) {
        return typeof maybeOptional === 'object'
            && Reflect.has(maybeOptional, 'isPresent');
    }
    describedAs(subject) {
        this.subject = subject;
        return this;
    }
    toString() {
        return this.subject;
    }
}
/**
 * @package
 */
function isDefined(value) {
    return value !== undefined
        && value !== null;
}
//# sourceMappingURL=Question.js.map